<!DOCTYPE HTML>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name=viewport content="width=device-width, initial-scale=1">

  <link rel="stylesheet" type="text/css" href="/css/style.css">

  <title>Jihang Li - Notes on Implementing P3</title>

  <script>
    window.addEventListener("message", function (event) {
      console.log(event.data);
      if (event.data === "toggle") {
        document.body.classList.toggle("light-theme");
      }
    });
  </script>
</head>

<body>
  <object type="text/html" data="/header.html" class="header"></object>

  <div>
    <h1>Notes on Implementing P<sup>3</sup></h1>

    <ul>
      <li><a href="#data-preprocessing">Data Preprocessing</a></li>
      <li><a href="#forward-pass">Forward Pass</tt></a></li>
    </ul>

    This note presumes that the reader has finished reading the
    <a href="https://docs.dgl.ai/tutorials/blitz/index.html">A Blitz Introduction to DGL</a>
    and the <a href="https://docs.dgl.ai/tutorials/dist/1_node_classification.html">Distributed Node Classification</a>
    documentations, and the contents are based on node classification only.

    <h2 id="data-preprocessing">Data Preprocessing</h2>
    <p>
      Before partitioning, it is crucial to ensure that the node labels in the
      DGL graph are stored for future usage:
    </p>

    <pre>
from dgl.distributed import partition_graph
from ogb.nodeproppred import DglNodePropPredDataset
import dgl

dataset = DglNodePropPredDataset("ogbn-arxiv")

graph, node_labels = dataset[0]
graph = dgl.add_reverse_edges(graph)

graph.ndata["label"] = node_labels[:, 0]
    </pre>

    <p>
      It is worth noting that the current documentation does not explicitly
      outline the necessity of this step. As a result, it is easy to overlook,
      potentially leading to issues when attempting to use code copied from
      DGL's documentation, as the absence of this step can impede its
      functionality.
    </p>

    <h2 id="forward-pass">Forward Pass</h2>
    <p>
      There are at least two ways to implement the forward pass as P<sup>3</sup>
      does, modifying DGL's built-in class or implement a new class from scratch.
    </p>

    <h3>Modifying DGL</h3>
    <p>
      To modify DGL's classes to enable the switching between model parallelism
      and data parallelism, it is essential to identify the appropriate points
      for inserting scatter and gather operations. Within DGL, the forward pass
      is accomplished by invoking the <tt>dgl.heterograph.DGLGraph.update_all</tt>
      function, which follows this call stack:
    </p>

    <pre>
dgl.heterograph.DGLGraph.update_all
|- dgl.core.message_passing
   |  |- dgl.core.invoke_gspmm: if message and reduce are built-in
   |                            else
   |- dgl.core.invoke_gsddmm:   message
      dgl.core.invoke_gspmm:    reduce
    </pre>

    <p>
      Re-implementing DGL's built-in message and reduce functions is a
      straightforward process, enabling us to consistently carry out the
      forward pass by invoking <tt>dgl.core.invoke_gsddmm</tt> and
      <tt>dgl.core.invoke_gspmm</tt>. The critical point for inserting scatter
      and gather functions lies between these two operations. This is where we
      can customize the behavior to seamlessly switch between model parallelism
      and data parallelism based on our requirements.
    </p>

    <h3>Implementing New Classes</h3>
    <p>
    Please visit the <a href="https://github.com/neur1n/p3" target="_blank">code</a>.
    </p>
  </div>
</body>
</html>
